<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - 爱像水墨青花</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="lflxp" /><meta name="description" content="一张图搞懂Kubernetes存储系统。
 本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 kubeadm安装kubernetes V1.11.1 集群
 容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。
Kubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。
 Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过volume属性来定义存储的类型，通过volumeMount来定义容器内的挂载点。 PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。 PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过StorageClassName、matchLabels或者matchExpressions三种方式。 StorageClass。  总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。
Volumes Docker提供了Volumes，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。
Volumes的类型  cephfs configMap、secret emptyDir hostPath local nfs persistentVolumeClaim  实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。
emptyDir emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为Memory。emptyDir特别适合在Pod内的不同容器间共享临时文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:tomcat-ccbnamespace:defaultlabels:app:tomcatnode:devops-103spec:containers:-name:tomcatimage:docker." /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.62.2 with theme even" />


<link rel="canonical" href="https://www.lflxp.cn/post/k8s-go/storage/readme/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="" />
<meta property="og:description" content="一张图搞懂Kubernetes存储系统。
 本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 kubeadm安装kubernetes V1.11.1 集群
 容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。
Kubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。
 Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过volume属性来定义存储的类型，通过volumeMount来定义容器内的挂载点。 PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。 PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过StorageClassName、matchLabels或者matchExpressions三种方式。 StorageClass。  总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。
Volumes Docker提供了Volumes，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。
Volumes的类型  cephfs configMap、secret emptyDir hostPath local nfs persistentVolumeClaim  实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。
emptyDir emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为Memory。emptyDir特别适合在Pod内的不同容器间共享临时文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:tomcat-ccbnamespace:defaultlabels:app:tomcatnode:devops-103spec:containers:-name:tomcatimage:docker." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.lflxp.cn/post/k8s-go/storage/readme/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="一张图搞懂Kubernetes存储系统。
 本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 kubeadm安装kubernetes V1.11.1 集群
 容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。
Kubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。
 Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过volume属性来定义存储的类型，通过volumeMount来定义容器内的挂载点。 PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。 PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过StorageClassName、matchLabels或者matchExpressions三种方式。 StorageClass。  总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。
Volumes Docker提供了Volumes，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。
Volumes的类型  cephfs configMap、secret emptyDir hostPath local nfs persistentVolumeClaim  实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。
emptyDir emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为Memory。emptyDir特别适合在Pod内的不同容器间共享临时文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:tomcat-ccbnamespace:defaultlabels:app:tomcatnode:devops-103spec:containers:-name:tomcatimage:docker.">

<meta itemprop="wordCount" content="427">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="一张图搞懂Kubernetes存储系统。
 本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 kubeadm安装kubernetes V1.11.1 集群
 容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。
Kubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。
 Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过volume属性来定义存储的类型，通过volumeMount来定义容器内的挂载点。 PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。 PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过StorageClassName、matchLabels或者matchExpressions三种方式。 StorageClass。  总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。
Volumes Docker提供了Volumes，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。
Volumes的类型  cephfs configMap、secret emptyDir hostPath local nfs persistentVolumeClaim  实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。
emptyDir emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为Memory。emptyDir特别适合在Pod内的不同容器间共享临时文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:tomcat-ccbnamespace:defaultlabels:app:tomcatnode:devops-103spec:containers:-name:tomcatimage:docker."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">琵琶</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">目录</li>
      </a><a href="/post/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">琵琶</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">目录</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#volumes">Volumes</a>
      <ul>
        <li><a href="#volumes的类型">Volumes的类型</a></li>
        <li><a href="#emptydir">emptyDir</a></li>
        <li><a href="#hostpath">hostPath</a></li>
        <li><a href="#local">local</a></li>
      </ul>
    </li>
    <li><a href="#persistent-volumes">Persistent Volumes</a>
      <ul>
        <li><a href="#persistent-volumes-的一些属性">Persistent Volumes 的一些属性</a></li>
        <li><a href="#状态">状态</a></li>
      </ul>
    </li>
    <li><a href="#persistentvolumeclaims">PersistentVolumeClaims</a></li>
    <li><a href="#storage-class">Storage Class</a></li>
    <li><a href="#参考资料">参考资料：</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="0001-01-01T00:00:00" title="January 1, 0001">January 1, 0001</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <p>一张图搞懂Kubernetes存储系统。</p>
<blockquote>
<p>本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 <a href="https://www.cnblogs.com/cocowool/p/kubeadm_install_kubernetes.html">kubeadm安装kubernetes V1.11.1 集群</a></p>
</blockquote>
<p>容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。</p>
<p>Kubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。</p>
<p><img src="./storage_basic.png" alt=""></p>
<ul>
<li>Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过<code>volume</code>属性来定义存储的类型，通过<code>volumeMount</code>来定义容器内的挂载点。</li>
<li>PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。</li>
<li>PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过<code>StorageClassName</code>、<code>matchLabels</code>或者<code>matchExpressions</code>三种方式。</li>
<li>StorageClass。</li>
</ul>
<p>总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。</p>
<h2 id="volumes">Volumes</h2>
<p>Docker提供了<a href="https://docs.docker.com/engine/admin/volumes/">Volumes</a>，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。</p>
<h3 id="volumes的类型">Volumes的类型</h3>
<ul>
<li><a href="https://github.com/kubernetes/examples/tree/master/staging/volumes/cephfs/">cephfs</a></li>
<li>configMap、secret</li>
<li>emptyDir</li>
<li>hostPath</li>
<li>local</li>
<li>nfs</li>
<li>persistentVolumeClaim</li>
</ul>
<p>实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。</p>
<h3 id="emptydir">emptyDir</h3>
<p>emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为<code>Memory</code>。emptyDir特别适合在Pod内的不同容器间共享临时文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">apiVersion<span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span>kind<span class="p">:</span><span class="w"> </span>Pod<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>tomcat-ccb<span class="w">
</span><span class="w">  </span>namespace<span class="p">:</span><span class="w"> </span>default<span class="w">
</span><span class="w">  </span>labels<span class="p">:</span><span class="w">
</span><span class="w">    </span>app<span class="p">:</span><span class="w"> </span>tomcat<span class="w">
</span><span class="w">    </span>node<span class="p">:</span><span class="w"> </span>devops<span class="m">-103</span><span class="w">
</span><span class="w"></span>spec<span class="p">:</span><span class="w">
</span><span class="w">  </span>containers<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>tomcat<span class="w">
</span><span class="w">    </span>image<span class="p">:</span><span class="w"> </span>docker.io/tomcat<span class="w">
</span><span class="w">    </span>volumeMounts<span class="p">:</span><span class="w">
</span><span class="w">    </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>tomcat-storage<span class="w">
</span><span class="w">      </span>mountPath<span class="p">:</span><span class="w"> </span>/data/tomcat<span class="w">
</span><span class="w">    </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>cache-storage<span class="w">
</span><span class="w">      </span>mountPath<span class="p">:</span><span class="w"> </span>/data/cache<span class="w">
</span><span class="w">    </span>ports<span class="p">:</span><span class="w">
</span><span class="w">    </span>-<span class="w"> </span>containerPort<span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">      </span>protocol<span class="p">:</span><span class="w"> </span>TCP<span class="w">
</span><span class="w">    </span>env<span class="p">:</span><span class="w">
</span><span class="w">      </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>GREETING<span class="w">
</span><span class="w">        </span>value<span class="p">:</span><span class="w"> </span><span class="s2">&#34;Hello from devops-103&#34;</span><span class="w">
</span><span class="w">  </span>volumes<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>tomcat-storage<span class="w">
</span><span class="w">    </span>hostPath<span class="p">:</span><span class="w">
</span><span class="w">      </span>path<span class="p">:</span><span class="w"> </span>/home/es<span class="w">
</span><span class="w">  </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>cache-storage<span class="w">
</span><span class="w">    </span>emptyDir<span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>可以将emptyDir指定到内存中，配置如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">volumes<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>html<span class="w">
</span><span class="w">    </span>emptyDir<span class="p">:</span><span class="w">
</span><span class="w">      </span>medium<span class="p">:</span><span class="w"> </span>Memory<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="hostpath">hostPath</h3>
<p>hostPath就是将Node节点的文件系统挂载到Pod中，在之前的例子中也可以看到用法。使用kubeadm部署的Kubernetes，其很多组件都使用了hostPath的类型，将宿主机的一些目录挂载到容器中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">apiVersion<span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span>kind<span class="p">:</span><span class="w"> </span>Pod<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>test-pd<span class="w">
</span><span class="w"></span>spec<span class="p">:</span><span class="w">
</span><span class="w">  </span>containers<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>image<span class="p">:</span><span class="w"> </span>k8s.gcr.io/test-webserver<span class="w">
</span><span class="w">    </span>name<span class="p">:</span><span class="w"> </span>test-container<span class="w">
</span><span class="w">    </span>volumeMounts<span class="p">:</span><span class="w">
</span><span class="w">    </span>-<span class="w"> </span>mountPath<span class="p">:</span><span class="w"> </span>/test-pd<span class="w">
</span><span class="w">      </span>name<span class="p">:</span><span class="w"> </span>test-volume<span class="w">
</span><span class="w">  </span>volumes<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>test-volume<span class="w">
</span><span class="w">    </span>hostPath<span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="c"># directory location on host</span><span class="w">
</span><span class="w">      </span>path<span class="p">:</span><span class="w"> </span>/data<span class="w">
</span><span class="w">      </span><span class="c"># this field is optional</span><span class="w">
</span><span class="w">      </span>type<span class="p">:</span><span class="w"> </span>Directory<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="local">local</h3>
<blockquote>
<p>A local volume represents a mounted local storage device such as a disk, partition or directory.</p>
</blockquote>
<p>local类型作为静态资源被PersistentVolume使用，不支持Dynamic provisioning。与hostPath相比，因为能够通过PersistentVolume的节点亲和策略来进行调度，因此比hostPath类型更加适用。local类型也存在一些问题，如果Node的状态异常，那么local存储将无法访问，从而导致Pod运行状态异常。使用这种类型存储的应用必须能够承受可用性的降低、可能的数据丢失等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">apiVersion<span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span>kind<span class="p">:</span><span class="w"> </span>PersistentVolume<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>www<span class="w">
</span><span class="w"></span>spec<span class="p">:</span><span class="w">
</span><span class="w">  </span>capacity<span class="p">:</span><span class="w">
</span><span class="w">    </span>storage<span class="p">:</span><span class="w"> </span>100Mi<span class="w">
</span><span class="w">  </span>volumeMode<span class="p">:</span><span class="w"> </span>Filesystem<span class="w">
</span><span class="w">  </span>accessModes<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;ReadWriteOnce&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">  </span>persistentVolumeReclaimPolicy<span class="p">:</span><span class="w"> </span>Delete<span class="w">
</span><span class="w">  </span>storageClassName<span class="p">:</span><span class="w"> </span>local-storage<span class="w">
</span><span class="w">  </span>local<span class="p">:</span><span class="w">
</span><span class="w">    </span>path<span class="p">:</span><span class="w"> </span>/home/es<span class="w">
</span><span class="w">  </span>nodeAffinity<span class="p">:</span><span class="w">
</span><span class="w">    </span>required<span class="p">:</span><span class="w">
</span><span class="w">      </span>nodeSelectorTerms<span class="p">:</span><span class="w">
</span><span class="w">      </span>-<span class="w"> </span>matchExpressions<span class="p">:</span><span class="w">
</span><span class="w">        </span>-<span class="w"> </span>key<span class="p">:</span><span class="w"> </span>kubernetes.io/hostname<span class="w">
</span><span class="w">          </span>operator<span class="p">:</span><span class="w"> </span>In<span class="w">
</span><span class="w">          </span>values<span class="p">:</span><span class="w">
</span><span class="w">          </span>-<span class="w"> </span>devops<span class="m">-102</span><span class="w">
</span><span class="w">          </span>-<span class="w"> </span>devops<span class="m">-103</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于使用了PV的Pod，Kubernetes会调度到具有对应PV的Node上，因此PV的节点亲和性 nodeAffinity 属性是必须的。</p>
<blockquote>
<p>PersistentVolume nodeAffinity is required when using local volumes. It enables the Kubernetes scheduler to correctly schedule Pods using local volumes to the correct node.</p>
</blockquote>
<h2 id="persistent-volumes">Persistent Volumes</h2>
<p>Persistent Volumes 提供了一个抽象层，向用户屏蔽了具体的存储实现形式。</p>
<ul>
<li>PersistentVolume PV：集群管理员提供的一块存储，是Volumes的插件。类似于Pod，但是具有独立于Pod的生命周期。具体存储可以是NFS、云服务商提供的存储服务。</li>
<li>PersistentVolumeClaim PVC：PVC是用户的存储请求，PVC消耗PV资源。</li>
</ul>
<p>生命周期：</p>
<ul>
<li>供给
<ul>
<li>静态供给</li>
<li>动态供给：动态供给的请求基于StorageClass，集群针对用户的PVC请求，可以产生动态供给。</li>
</ul>
</li>
<li>绑定 Binding</li>
<li>使用</li>
<li>在用对象保护：对于正在使用的PV提供了保护机制，正在使用的PV如果被用户删除，PV的删除会推迟到用户对PV的使用结束。</li>
<li>重用 Reclaim 策略
<ul>
<li>保留 Retain：保留现场，Kubernetes等待用户手工处理数据。</li>
<li>删除 Delete：Kubernetes会自动删除数据</li>
<li>重用 Recycle：这个策略已经不推荐使用了，应该使用 Dynamic Provisioning 代替。</li>
</ul>
</li>
<li>扩容。主要是对于一些云存储类型，例如gcePersistentDisk、Azure Disk提供了扩容特性，在1.11版本还处于测试阶段。</li>
</ul>
<p>PersistenVolume 这个功能目前是通过Plugin插件的形式实现的，目前的版本V1.11.1有19中，特别关注了一下HostPath。</p>
<blockquote>
<p>HostPath (Single node testing only – local storage is not supported in any way and WILL NOT WORK in a multi-node cluster)</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">apiVersion<span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span>kind<span class="p">:</span><span class="w"> </span>PersistentVolume<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>pv-localstorage<span class="w">
</span><span class="w"></span>spec<span class="p">:</span><span class="w">
</span><span class="w">  </span>capacity<span class="p">:</span><span class="w">
</span><span class="w">    </span>storage<span class="p">:</span><span class="w"> </span>100Mi<span class="w">
</span><span class="w">  </span>accessModes<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>ReadWriteOnce<span class="w">
</span><span class="w">  </span>-<span class="w"> </span>ReadOnlyMany<span class="w">
</span><span class="w">  </span>persistentVolumeReclaimPolicy<span class="p">:</span><span class="w"> </span>Retain<span class="w">
</span><span class="w">  </span>storageClassName<span class="p">:</span><span class="w"> </span>local-storage<span class="w">
</span><span class="w">  </span>local<span class="p">:</span><span class="w">
</span><span class="w">    </span>path<span class="p">:</span><span class="w"> </span>/home<span class="w">
</span><span class="w">  </span>nodeAffinity<span class="p">:</span><span class="w">
</span><span class="w">    </span>required<span class="p">:</span><span class="w">
</span><span class="w">      </span>nodeSelectorTerms<span class="p">:</span><span class="w">
</span><span class="w">      </span>-<span class="w"> </span>matchExpressions<span class="p">:</span><span class="w">
</span><span class="w">        </span>-<span class="w"> </span>key<span class="p">:</span><span class="w"> </span>kubernetes.io/hostname<span class="w">
</span><span class="w">          </span>operator<span class="p">:</span><span class="w"> </span>In<span class="w">
</span><span class="w">          </span>values<span class="p">:</span><span class="w">
</span><span class="w">          </span>-<span class="w"> </span>devops<span class="m">-102</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>PV创建后就会处于Available状态，等待PVC的申请。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@devops-101 ~<span class="o">]</span><span class="c1"># kubectl apply -f pv-local.yaml</span> 
persistentvolume/pv-localstorage created
<span class="o">[</span>root@devops-101 ~<span class="o">]</span><span class="c1"># kubectl get pv</span>
NAME              CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                 STORAGECLASS    REASON    AGE
pv-localstorage   100Mi      RWO,ROX        Retain           Available                         local-storage             6s
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>这里使用了local-storage的类型，必须有节点亲和性，节点亲和性的内容可以参考 <a href="https://www.cnblogs.com/cocowool/p/kubernetes_affinity.html">Kubernetes中的亲和性与反亲和性</a></p>
</blockquote>
<h3 id="persistent-volumes-的一些属性">Persistent Volumes 的一些属性</h3>
<ul>
<li>Capacity：一般情况PV拥有固定的容量</li>
<li>Volume Mode：在1.9版本中是alpha特性，允许设置 filesystem 使用文件系统（默认），设置 raw 使用裸设备。</li>
<li>Access Modes</li>
<li>Class：可以设置成StorageClass的名称。具有Class属性的PV只能绑定到还有相同CLASS名称的PVC上。没有CLASS的PV只能绑定到没有CLASS的PVC上。</li>
<li>Reclaim Policy</li>
</ul>
<h3 id="状态">状态</h3>
<ul>
<li>Available：未被任何PVC使用</li>
<li>Bound：绑定到了PVC上</li>
<li>Released：PVC被删掉，资源未被使用</li>
<li>Failed：自动回收失败</li>
</ul>
<h2 id="persistentvolumeclaims">PersistentVolumeClaims</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">kind<span class="p">:</span><span class="w"> </span>PersistentVolumeClaim<span class="w">
</span><span class="w"></span>apiVersion<span class="p">:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>pvc-localstorage<span class="w">
</span><span class="w"></span>spec<span class="p">:</span><span class="w">
</span><span class="w">  </span>storageClassName<span class="p">:</span><span class="w"> </span>local-storage<span class="w">
</span><span class="w">  </span>accessModes<span class="p">:</span><span class="w">
</span><span class="w">    </span>-<span class="w"> </span>ReadWriteOnce<span class="w">
</span><span class="w">  </span>resources<span class="p">:</span><span class="w">
</span><span class="w">    </span>requests<span class="p">:</span><span class="w">
</span><span class="w">      </span>storage<span class="p">:</span><span class="w"> </span>30Mi<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一些属性</p>
<ul>
<li>Access Modes</li>
<li>Volume Modes</li>
<li>Resources</li>
<li>Selector：PVC可以通过标签选择器选择PV资源。可以包含两个字段<code>matchLabels</code>和<code>matchExpressions</code>。</li>
<li>storageClassName 类似标签选择器，通过storagClassName 来确定PV资源。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@devops-101 ~<span class="o">]</span><span class="c1"># kubectl apply -f pvc-local.yaml</span> 
persistentvolumeclaim/pvc-localstorage created
<span class="o">[</span>root@devops-101 ~<span class="o">]</span><span class="c1"># kubectl get pvc</span>
NAME               STATUS    VOLUME            CAPACITY   ACCESS MODES   STORAGECLASS    AGE
pvc-localstorage   Bound     pv-localstorage   100Mi      RWO,ROX        local-storage   7s
<span class="o">[</span>root@devops-101 ~<span class="o">]</span><span class="c1"># kubectl get pv</span>
NAME              CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM                      STORAGECLASS    REASON    AGE
pv-localstorage   100Mi      RWO,ROX        Retain           Bound     default/pvc-localstorage   local-storage             8m
</code></pre></td></tr></table>
</div>
</div><h2 id="storage-class">Storage Class</h2>
<p>StorageClass为管理员提供了一种描述存储类型的方法。通常情况下，管理员需要手工创建所需的存储资源。利用动态容量供给的功能，就可以实现动态创建PV的能力。动态容量供给 Dynamic Volume Provisioning 主要依靠StorageClass中指定的<code>provisioner</code>。如果希望集群在没有指定StorageClass的情况下也能提供动态扩容的能力，需要设置<code>DefaultStorageClass</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">kind<span class="p">:</span><span class="w"> </span>StorageClass<span class="w">
</span><span class="w"></span>apiVersion<span class="p">:</span><span class="w"> </span>storage.k8s.io/v1<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>local-storage<span class="w">
</span><span class="w"></span>provisioner<span class="p">:</span><span class="w"> </span>kubernetes.io/no-provisioner<span class="w">
</span><span class="w"></span>volumeBindingMode<span class="p">:</span><span class="w"> </span>WaitForFirstConsumer<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180710163655709-89635310.png" alt=""></p>
<h2 id="参考资料">参考资料：</h2>
<ol>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes">Kubernetes Storage</a></li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">Configure a Pod to Use a PersistentVolume for Storage</a></li>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes">Persistent Volumes</a></li>
<li><a href="https://blog.csdn.net/liukuan73/article/details/60089305">kubernetes存储系统介绍(Volume、PV、dynamic provisioning)</a></li>
<li><a href="https://blog.csdn.net/qq_26923057/article/details/52713463">Kubernetes 1.4 新特性 持久卷 </a></li>
<li><a href="http://dockone.io/article/2016?utm_source=tuicool&amp;utm_medium=referral">DockOne微信分享（一零三）：Kubernetes 有状态集群服务部署与管理</a></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">lflxp</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/k8s-go/storage/configmap/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"></span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/soldierassault/chapter01/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '0001-01-01 00:00:00 \x2b0000 UTC',
        title: '',
        link: decodeURI(location.href),
        desc: '一张图搞懂Kubernetes存储系统。\n 本文环境为Kubernetes V1.11，操作系统版本为 CentOs 7.3，Kubernetes集群安装可以参考 kubeadm安装kubernetes V1.11.1 集群\n 容器中的存储都是临时的，因此Pod重启的时候，内部的数据会发生丢失。实际应用中，我们有些应用是无状态，有些应用则需要保持状态数据，确保Pod重启之后能够读取到之前的状态数据，有些应用则作为集群提供服务。这三种服务归纳为无状态服务、有状态服务以及有状态的集群服务，其中后面两个存在数据保存与共享的需求，因此就要采用容器外的存储方案。\nKubernetes中存储中有四个重要的概念：Volume、PersistentVolume PV、PersistentVolumeClaim PVC、StorageClass。掌握了这四个概念，就掌握了Kubernetes中存储系统的核心。我用一张图来说明这四者之间的关系。\n Volumes是最基础的存储抽象，其支持多种类型，包括本地存储、NFS、FC以及众多的云存储，我们也可以编写自己的存储插件来支持特定的存储系统。Volume可以被Pod直接使用，也可以被PV使用。普通的Volume和Pod之间是一种静态的绑定关系，在定义Pod的同时，通过volume属性来定义存储的类型，通过volumeMount来定义容器内的挂载点。 PersistentVolume。与普通的Volume不同，PV是Kubernetes中的一个资源对象，创建一个PV相当于创建了一个存储资源对象，这个资源的使用要通过PVC来请求。 PersistentVolumeClaim。PVC是用户对存储资源PV的请求，根据PVC中指定的条件Kubernetes动态的寻找系统中的PV资源并进行绑定。目前PVC与PV匹配可以通过StorageClassName、matchLabels或者matchExpressions三种方式。 StorageClass。  总结一句话就是，Volumes可以直接使用，但是与存储类型有强绑定关系，PV、PVC将Pod挂载与具体存储类型进行了解耦，StorageClass提供了自动存储供给的定义机制。\nVolumes Docker提供了Volumes，Volume 是磁盘上的文件夹并且没有生命周期的管理。Kubernetes 中的 Volume 是存储的抽象，并且能够为Pod提供多种存储解决方案。Volume 最终会映射为Pod中容器可访问的一个文件夹或裸设备，但是背后的实现方式可以有很多种。\nVolumes的类型  cephfs configMap、secret emptyDir hostPath local nfs persistentVolumeClaim  实际上Volume还支持gitRepo、gcePersistentDisk、awsElasticBlockStore、azureDisk等类型的存储，但是在本地的测试环境很少用到，就不做介绍了，感兴趣的可以去官方了解。\nemptyDir emptyDir在Pod被分配到Node上之后创建，并且在Pod运行期间一直存在，即它的生命周期和Pod一致。初始的时候为一个空文件夹，当Pod从Node中移除时，emptyDir将被永久删除。Container的意外退出并不会导致emptyDir被删除。emptyDir适用于一些临时存放数据的场景。默认情况下，emptyDir存储在Node支持的介质上，不管是磁盘、SSD还是网络存储，也可以设置为Memory。emptyDir特别适合在Pod内的不同容器间共享临时文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:tomcat-ccbnamespace:defaultlabels:app:tomcatnode:devops-103spec:containers:-name:tomcatimage:docker.',
        owner: 'lflxp',
        repo: 'https:\/\/github.com\/lflxp\/lflxp.github.com',
        oauth: {
          client_id: '',
          client_secret: ''
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:382023823@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/lflxp" class="iconfont icon-github" title="github"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-douban" title="douban"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-pocket" title="pocket"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-instagram" title="instagram"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="https://www.lflxp.cn" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://www.lflxp.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2016 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">lflxp.cn 版权所有 ICP证：<a href='http://www.beian.miit.gov.cn' target='_blank'>渝ICP备17011066号-1</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', '渝ICP备17011066号-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
